<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>M&M's Sketchpad ‚Äî Simple Drawing App</title>
  <style>
    :root{ --bg:#0b0c10; --ui:#111216; --ink:#f5f7fb; --dark:#1a1c24; --accent:#36c88a; --muted:#6c768a; --danger:#e25555; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
    .app{position:fixed; inset:0; display:grid; grid-template-rows: 1fr auto;}
    #stage{position:relative; background:white;}
    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none; cursor: crosshair;}

    .title{position:absolute; top:12px; left:12px; z-index:6; margin:0; font-size:18px; font-weight:600; color:var(--dark); letter-spacing:-0.02em;}

    .zoom-controls{position:absolute; top:50px; left:12px; z-index:7; display:flex; gap:6px; align-items:center; background:var(--ui); padding:8px; border-radius:12px; border:1px solid #2a2d36; box-shadow:0 2px 10px rgba(0,0,0,0.2);}
    .zoom-controls button{background:none; border:1px solid #2a2d36; padding:6px 8px; font-size:13px; font-weight:600; color:var(--ink); border-radius:8px; cursor:pointer;}
    .zoom-controls button:hover{background:var(--accent); color:white; border-color:transparent;}
    .zoom-controls button:disabled{opacity:.4; cursor:not-allowed;}
    #zoomLevel{font-size:14px; color:var(--ink); min-width:46px; text-align:center;}

    .save-btn{position:absolute; top:12px; right:12px; z-index:7; background:var(--ui); color:var(--ink); border:1px solid #2a2d36; border-radius:12px; padding:10px 14px; font-weight:600; box-shadow:0 6px 20px rgba(0,0,0,.3);}
    .save-btn:hover{outline:2px solid var(--accent);}
    #paletteBtn.save-btn{right:120px}

    .save-btn, .swatch, button, .brushes button, .quick-cell, .zoom-controls button { transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); }
    .save-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(54, 200, 138, 0.3); }
    .swatch:hover:not(.palette) { transform: scale(1.1); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .brushes button:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .sheet .close:hover { background: #221b1b; transform: translateY(-1px); }
    .quick-cell:hover { transform: scale(1.1); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .zoom-controls button:hover { transform: scale(1.02); }

    .swatch-bar{display:flex; gap:10px; padding:10px; background:linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.25)); align-items:center; justify-content:center; border-top:1px solid #252835;}
    .swatch{width:36px; height:36px; border-radius:8px; border:2px solid rgba(255,255,255,.35); box-shadow: inset 0 0 0 2px rgba(0,0,0,.25); position:relative;}
    .swatch.active{outline:3px solid var(--accent);}
    .swatch.empty{border-style:dashed; border-color: rgba(255,255,255,.25); background:#f8f9fa;}
    .swatch .slot-index{position:absolute; bottom:-18px; left:0; right:0; text-align:center; font-size:10px; color:var(--muted);}
    .swatch.palette{display:flex; align-items:center; justify-content:center; font-size:18px; color:#fff; border-color:#3b3e4d;}
    .swatch.palette::after{content:"üé®";}

    .modal{position:absolute; inset:0; display:none; align-items:center; justify-content:center; backdrop-filter: blur(8px); background: rgba(0,0,0,0.4); z-index:999;}
    .modal.open{display:flex;}
    @keyframes modalIn { from { opacity:0; transform: scale(0.95) translateY(10px);} to{opacity:1; transform: scale(1) translateY(0);} }
    .modal.open .sheet { animation: modalIn 0.3s ease-out forwards; }
    .sheet{width:min(720px, 92vw); background:var(--ui); border:1px solid #2a2d36; border-radius:18px; box-shadow:0 30px 60px rgba(0,0,0,.45); overflow:hidden;}
    .sheet header{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; background:#0f1015; border-bottom:1px solid #2a2d36;}
    .sheet h2{margin:0; font-size:18px;}
    .sheet .close{background:#191b22; border:1px solid #2a2d36; color:var(--ink); padding:8px 10px; border-radius:10px;}
    .sheet .content{display:grid; gap:16px; grid-template-columns: 1fr; padding:16px;}
    @media(min-width:720px){ .sheet .content{grid-template-columns: 1fr 1fr;} }

    fieldset{border:1px solid #2a2d36; border-radius:14px; padding:12px;}
    legend{padding:0 6px; color:var(--muted);}
    label{display:block; margin:8px 0 6px; font-size:14px; color:#d1d6e2}
    input[type="range"]{width:100%; height: 6px; background: #2a2d36; border-radius: 3px;}
    input[type="range"]::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; background: var(--accent); border-radius: 50%; cursor: pointer; }
    input[type="color"] { width: 100%; height: 50px; padding: 4px; border: 1px solid #2a2d36; border-radius: 8px; background: #191b22; cursor: pointer; }

    .quick-colors { margin-top: 12px; }
    .quick-colors h3 { margin: 0 0 8px 0; font-size: 14px; color: var(--ink); text-align: center; }
    .quick-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(48px, 1fr)); gap: 8px; justify-items: center; }
    @media (min-width: 720px) { .quick-grid { grid-template-columns: repeat(5, 1fr); } }
    .quick-cell { width: 48px; height: 48px; aspect-ratio: 1; border-radius: 12px; border: 2px solid rgba(255,255,255,.4); cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .quick-cell.active { outline: 3px solid var(--accent); transform: scale(1.05); }

    .brushes{display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px;}
    .brushes button{padding:10px 8px; border-radius:12px; background:#191b22; border:1px solid #2a2d36; color:#d7dbea; font-weight:600;}
    .brushes button.active{outline:3px solid var(--accent);}

    .swatch-grid{display:grid; grid-template-columns: repeat(8, 1fr); gap:8px;}
    .swatch-grid .cell{aspect-ratio:1/1; border-radius:8px; border:2px solid rgba(255,255,255,.35);}
    .swatch-grid .cell.empty{border-style:dashed; background:#f8f9fa;}
    .grid-actions{display:flex; gap:8px; margin-top:10px;}

    .hint{font-size:12px; color:var(--muted);}

    /* Navigator (mini-map) */
    .navigator{
      position:absolute; right:12px; bottom:12px; z-index:7;
      background:rgba(17,18,22,.85); border:1px solid #2a2d36; border-radius:12px;
      box-shadow:0 10px 24px rgba(0,0,0,.35); padding:10px; display:flex; gap:8px; align-items:center;
      user-select:none; -webkit-user-select:none;
    }
    .navigator canvas{ width:180px; height:120px; display:block; border-radius:8px; background:#0b0c10; }
    .nav-controls{ display:flex; flex-direction:column; gap:6px; }
    .nav-controls button{ background:#191b22; color:var(--ink); border:1px solid #2a2d36; border-radius:8px; padding:6px 8px; font-weight:600; cursor:pointer; }
    .nav-controls button:hover{ background:var(--accent); color:white; border-color:transparent; }
    .nav-hidden{ display:none; }
  </style>
</head>
<body>
  <div class="app">
    <div id="stage">
      <h1 class="title">Mae's Sketchpad</h1>

      <div class="zoom-controls">
        <button id="zoomOut" title="Zoom out (Ctrl/‚åò -)">‚àí</button>
        <span id="zoomLevel">1.0x</span>
        <button id="zoomIn" title="Zoom in (Ctrl/‚åò +)">+</button>
        <button id="resetView" title="Reset (Ctrl/‚åò 0)">Reset</button>
        <button id="fitView" title="Fit to strokes">Fit</button>
        <button id="undoBtn" title="Undo last (Ctrl/‚åò+Z)">Undo</button>
        <button id="redoBtn" title="Redo (Ctrl/‚åò+Y or Shift+Ctrl/‚åò+Z)">Redo</button>
      </div>

      <canvas id="canvas"></canvas>

      <button class="save-btn" id="paletteBtn" title="Open colours (P or C)">üé® Colours</button>
      <button class="save-btn" id="saveBtn" title="Save drawing as PNG">Save</button>

      <!-- Navigator -->
      <div class="navigator" id="navigator">
        <canvas id="navCanvas" width="360" height="240" aria-label="Navigator mini-map"></canvas>
        <div class="nav-controls">
          <button id="navToggle" title="Show/Hide (N)">üëÅ Hide</button>
          <button id="navFit" title="Fit view">Fit</button>
        </div>
      </div>

      <!-- Palette -->
      <div class="modal" id="paletteModal" aria-hidden="true">
        <div class="sheet" role="dialog" aria-modal="true" aria-labelledby="paletteTitle">
          <header>
            <h2 id="paletteTitle">Colours & Brushes</h2>
            <button class="close" id="closePalette">Close</button>
          </header>

          <div class="content">
            <fieldset>
              <legend>Colour</legend>
              <div class="picker-section">
                <label for="colorPicker">Pick colour</label>
                <input id="colorPicker" type="color" value="#3a86ff" />
              </div>
              <div class="quick-colors">
                <h3>Quick picks</h3>
                <div class="quick-grid" id="quickGrid"></div>
              </div>
              <p class="hint">Tip: Tap any saved square below to set current colour. Long-press a square to overwrite it.</p>
              <div class="swatch-grid" id="swatchGrid"></div>
              <div class="grid-actions">
                <button id="addSwatch">Add current colour</button>
                <button id="clearSwatches" title="Remove all saved colours" style="color:#fff;background:#2a2d36;border:1px solid #3b3e4d">Clear colours</button>
                <button id="clearCanvasBtn" style="margin-left:auto;color:#fff;background:#8c2f2f;border:1px solid #a44747">üßπ Clear drawing</button>
              </div>
            </fieldset>

            <fieldset>
              <legend>Brush</legend>
              <div class="brushes" id="brushes">
                <button data-brush="pencil">‚úèÔ∏è Pencil</button>
                <button data-brush="fine">üñäÔ∏è Fine pen</button>
                <button data-brush="marker">üñçÔ∏è Marker</button>
                <button data-brush="highlighter">üñåÔ∏è Highlighter</button>
                <button data-brush="eraser" style="grid-column: span 2; background:#221b1b; border-color:#3b2a2a">üßº Eraser</button>
              </div>
              <label for="size">Thickness</label>
              <input id="size" type="range" min="1" max="80" value="8" />
              <p class="hint">Brush sizes are scaled to your screen‚Äôs pixel density so strokes look crisp.</p>
            </fieldset>
          </div>
        </div>
      </div>
    </div>

    <div class="swatch-bar" id="swatchBar" aria-label="Saved colours"></div>
  </div>

<script>
(function(){
  // ==== Canvas + transforms (HiDPI)
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: false });
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  // Offscreen strokes layer to isolate erasing from white background
  const strokeLayer = document.createElement('canvas');
  const sctx = strokeLayer.getContext('2d', { willReadFrequently:false });

  function syncLayerSizes(){
    const rect = canvas.getBoundingClientRect();
    dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    canvas.width = w; canvas.height = h;
    strokeLayer.width = w; strokeLayer.height = h;
  }

  // ==== View state (persisted)
  const Z_KEY = 'maesSketchpad.zoom.v2';
  const P_KEY = 'maesSketchpad.pan.v2';
  const NAV_KEY = 'maesSketchpad.navigator.visible.v1';
  let zoom = clamp(parseFloat(localStorage.getItem(Z_KEY) || '1'), 0.1, 8);
  let pan = loadPan();

  function loadPan(){ try { return JSON.parse(localStorage.getItem(P_KEY) || '{"x":0,"y":0}'); } catch(e){ return {x:0,y:0}; } }
  function saveView(){
    localStorage.setItem(Z_KEY, String(zoom.toFixed(3)));
    localStorage.setItem(P_KEY, JSON.stringify({x:pan.x, y:pan.y}));
  }

  function resize(){ syncLayerSizes(); redraw(); }

  // ==== Drawing state
  let currentColor = window.localStorage.getItem('maesketchpad.currentColor') || '#3a86ff';
  let brush = window.localStorage.getItem('maesketchpad.brush') || 'pencil';
  let size = parseInt(window.localStorage.getItem('maesketchpad.size') || '8', 10);

  const SWATCH_KEY = 'maesketchpad.swatches.v1';
  let swatches = [];
  try { swatches = JSON.parse(localStorage.getItem(SWATCH_KEY) || '[]'); } catch(e){ swatches = []; }

  const STROKE_KEY = 'maesketchpad.strokes.v1';
  let strokes = [];
  try { strokes = JSON.parse(localStorage.getItem(STROKE_KEY) || '[]'); } catch(e){ strokes = []; }

  let currentStroke = null;
  let drawing = false;

  const QUICK_COLORS = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
    '#FF9F43', '#00D2D3', '#74B9FF', '#00B894', '#E17055',
    '#FD79A8', '#6C5CE7', '#A29BFE', '#FD9843', '#FDCB6E',
    '#E8F5E8', '#FFF5EE', '#F0F8FF', '#FFE4E1', '#F5FFFA'  /* fixed */
  ];

  // Undo/Redo
  let redoStack = [];

  // ==== Redraw (offscreen layer for strokes, identity composite to main)
  function redraw() {
    const rect = canvas.getBoundingClientRect();
    const vw = rect.width, vh = rect.height;

    // 1) Draw strokes on offscreen layer in world space with DPR
    sctx.setTransform(dpr,0,0,dpr,0,0);   // device pixels
    sctx.clearRect(0,0,strokeLayer.width,strokeLayer.height);
    sctx.translate(pan.x, pan.y);
    sctx.scale(zoom, zoom);
    strokes.forEach(s => drawStroke(sctx, s));
    if (currentStroke) drawStroke(sctx, currentStroke);

    // 2) Composite to main canvas at *identity* (avoid double-DPR scaling)
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(strokeLayer, 0, 0); // 1:1 pixels

    // 3) Navigator
    drawNavigator();

    updateUndoRedoUI();
  }

  function drawStroke(targetCtx, stroke) {
    const isEraser = stroke.brush === 'eraser';
    targetCtx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
    if (!isEraser) targetCtx.strokeStyle = stroke.color;

    let alpha = 1;
    switch (stroke.brush) {
      case 'pencil': alpha = 0.95; break;
      case 'fine': alpha = 0.98; break;
      case 'marker': alpha = 0.92; break;
      case 'highlighter': alpha = 0.35; break;
    }
    targetCtx.globalAlpha = alpha;

    let factor = { pencil: 0.9, fine: 0.5, marker: 1.6, highlighter: 2.2, eraser: 2 }[stroke.brush];
    let baseLw = stroke.size * factor;
    if (stroke.brush === 'fine') baseLw = Math.max(1, baseLw);
    targetCtx.lineWidth = baseLw;
    targetCtx.lineCap = 'round';
    targetCtx.lineJoin = 'round';

    if (!stroke.points || stroke.points.length < 1) return;
    targetCtx.beginPath();
    targetCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
    for (let i = 1; i < stroke.points.length; i++) {
      targetCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
    }
    targetCtx.stroke();
  }

  // ==== Coordinate helpers
  function screenToWorld(vx, vy){ return { x: (vx - pan.x) / zoom, y: (vy - pan.y) / zoom }; }
  function eventToCanvasClient(e){
    const r = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches && e.touches[0]) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
    else { clientX = e.clientX; clientY = e.clientY; }
    return { vx: clientX - r.left, vy: clientY - r.top };
  }

  // ==== Draw engine
  function start(e) {
    if (spaceDown || e.button === 1) return;
    if (e.touches && e.touches.length > 1) return;
    e.preventDefault();
    drawing = true;
    if (e.pointerId !== undefined) canvas.setPointerCapture?.(e.pointerId);
    const {vx, vy} = eventToCanvasClient(e);
    const p = screenToWorld(vx, vy);
    currentStroke = { brush, color: currentColor, size, points: [p] };
    redraw();
  }
  function move(e) {
    if (isPanning) return;
    if (!drawing || (e.touches && e.touches.length > 1)) return;
    e.preventDefault();
    const {vx, vy} = eventToCanvasClient(e);
    const p = screenToWorld(vx, vy);
    currentStroke.points.push(p);
    redraw();
  }
  function end(e) {
    try { if (e && e.pointerId !== undefined) canvas.releasePointerCapture?.(e.pointerId); } catch (err) {}
    if (drawing && currentStroke && currentStroke.points.length > 1) {
      strokes.push(currentStroke);
      persistStrokes();
      redoStack = [];
    }
    drawing = false;
    currentStroke = null;
    redraw();
    updateUndoRedoUI();
  }
  canvas.addEventListener('pointerdown', start, {passive: false});
  canvas.addEventListener('pointermove', move, {passive: false});
  window.addEventListener('pointerup', end, {passive: true});
  window.addEventListener('pointercancel', end, {passive: true});
  canvas.addEventListener('touchmove', e => e.preventDefault(), {passive: false});

  // ==== Pan (Space-drag, middle-mouse drag)
  let isPanning = false;
  let spaceDown = false;
  let lastPan = {x:0, y:0};

  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Space') { spaceDown = true; canvas.style.cursor = 'grab'; }
    if ((e.ctrlKey||e.metaKey) && (e.key === '+' || e.key === '=')) { e.preventDefault(); zoomBy(1.2); }
    if ((e.ctrlKey||e.metaKey) && (e.key === '-' )) { e.preventDefault(); zoomBy(1/1.2); }
    if ((e.ctrlKey||e.metaKey) && (e.key === '0' )) { e.preventDefault(); resetView(); }
    if (e.key.toLowerCase()==='n') toggleNavigator();
    if (e.key.toLowerCase()==='p' || e.key.toLowerCase()==='c') openPalette();
    if (e.key.toLowerCase()==='e'){ brush='eraser'; localStorage.setItem('maesketchpad.brush', brush); renderBrushButtons(); }
    if ((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key.toLowerCase() === 'z')) { e.preventDefault(); undoLast(); }
    if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) { e.preventDefault(); redoLast(); }
  }, {passive:false});
  window.addEventListener('keyup', (e)=>{ if (e.code === 'Space') { spaceDown = false; if(!isPanning) canvas.style.cursor = 'crosshair'; } });
  canvas.addEventListener('pointerdown', (e)=>{
    if (spaceDown || e.button === 1) {
      isPanning = true;
      if (e.pointerId !== undefined) canvas.setPointerCapture?.(e.pointerId);
      lastPan = { x: e.clientX, y: e.clientY };
      canvas.style.cursor = 'grabbing';
      e.preventDefault();
    }
  }, {passive:false});
  canvas.addEventListener('pointermove', (e)=>{
    if (!isPanning) return;
    const dx = e.clientX - lastPan.x;
    const dy = e.clientY - lastPan.y;
    pan.x += dx; pan.y += dy;
    lastPan = { x: e.clientX, y: e.clientY };
    saveView(); redraw();
  }, {passive:false});
  canvas.addEventListener('pointerup', (e)=>{
    if (isPanning) {
      isPanning = false;
      try { if (e.pointerId !== undefined) canvas.releasePointerCapture?.(e.pointerId); } catch(err){}
      canvas.style.cursor = spaceDown ? 'grab' : 'crosshair';
    }
  });

  // ==== Wheel & double-click zoom
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const factor = Math.pow(1.2, -e.deltaY / 100);
    const rect = canvas.getBoundingClientRect();
    const vx = e.clientX - rect.left;
    const vy = e.clientY - rect.top;
    setZoomAt(vx, vy, clamp(zoom * factor, 0.1, 8));
  }, {passive: false});
  canvas.addEventListener('dblclick', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const vx = e.clientX - rect.left;
    const vy = e.clientY - rect.top;
    const factor = e.shiftKey ? 1/1.4 : 1.4;
    setZoomAt(vx, vy, clamp(zoom * factor, 0.1, 8));
  });

  // ==== Pinch zoom
  let pinch = null;
  canvas.addEventListener('touchstart', (e)=>{
    if (e.touches.length === 2) {
      e.preventDefault();
      const [a,b] = e.touches;
      pinch = { startDist: Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY), startZoom: zoom, center: touchCenter(e.touches) };
    }
  }, {passive:false});
  canvas.addEventListener('touchmove', (e)=>{
    if (pinch && e.touches.length === 2) {
      e.preventDefault();
      const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
      const rect = canvas.getBoundingClientRect();
      const c = pinch.center;
      const vx = c.x - rect.left, vy = c.y - rect.top;
      const newZoom = clamp(pinch.startZoom * (dist / pinch.startDist), 0.1, 8);
      setZoomAt(vx, vy, newZoom);
    }
  }, {passive:false});
  canvas.addEventListener('touchend', ()=>{ pinch = null; }, {passive:true});
  function touchCenter(touches){ return { x:(touches[0].clientX + touches[1].clientX)/2, y:(touches[0].clientY + touches[1].clientY)/2 }; }

  // ==== View helpers
  const zoomLevelEl = document.getElementById('zoomLevel');
  function setZoomAt(vx, vy, newZoom){
    newZoom = clamp(newZoom, 0.1, 8);
    const world = screenToWorld(vx, vy);
    zoom = newZoom;
    pan.x = vx - world.x * zoom;
    pan.y = vy - world.y * zoom;
    zoomLevelEl.textContent = zoom.toFixed(1) + 'x';
    saveView();
    redraw();
  }
  function zoomBy(factor){
    const rect = canvas.getBoundingClientRect();
    setZoomAt(rect.width/2, rect.height/2, clamp(zoom * factor, 0.1, 8));
  }
  function resetView(){
    zoom = 1; pan = {x:0,y:0};
    zoomLevelEl.textContent = '1.0x';
    saveView(); redraw();
  }
  function fitView(){
    const box = strokesBounds(strokes);
    if (!box) { resetView(); return; }
    const rect = canvas.getBoundingClientRect();
    const pad = 40;
    const w = Math.max(1, box.maxX - box.minX);
    const h = Math.max(1, box.maxY - box.minY);
    const zx = (rect.width - pad*2) / w;
    const zy = (rect.height - pad*2) / h;
    const target = clamp(Math.min(zx, zy), 0.1, 8);
    zoom = target;
    const cx = (box.minX + box.maxX) / 2;
    const cy = (box.minY + box.maxY) / 2;
    pan.x = rect.width/2 - cx * zoom;
    pan.y = rect.height/2 - cy * zoom;
    zoomLevelEl.textContent = zoom.toFixed(1) + 'x';
    saveView(); redraw();
  }
  function strokesBounds(arr){
    if (!arr || !arr.length) return null;
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const s of arr){
      if (!s.points || !s.points.length) continue;
      for (const p of s.points){
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
      }
    }
    if (!isFinite(minX)) return null;
    return {minX, minY, maxX, maxY};
  }
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // Buttons
  document.getElementById('zoomIn').addEventListener('click', ()=> zoomBy(1.2));
  document.getElementById('zoomOut').addEventListener('click', ()=> zoomBy(1/1.2));
  document.getElementById('resetView').addEventListener('click', resetView);
  document.getElementById('fitView').addEventListener('click', fitView);

  // ==== Save (viewport-only, opaque) ====
  function commitCurrentStroke(){
    if (currentStroke && currentStroke.points && currentStroke.points.length > 1) {
      strokes.push(currentStroke);
      persistStrokes();
      redoStack = [];
    }
    currentStroke = null;
    drawing = false;
  }
  document.getElementById('saveBtn').addEventListener('click', () => {
    commitCurrentStroke();
    redraw(); // ensure latest state rendered to main

    // Export exactly what's visible (main canvas pixels), with opaque white bg
    const out = document.createElement('canvas');
    out.width = canvas.width;
    out.height = canvas.height;
    const octx = out.getContext('2d');
    octx.fillStyle = '#fff';
    octx.fillRect(0, 0, out.width, out.height);
    octx.drawImage(canvas, 0, 0);

    const a = document.createElement('a');
    a.download = `MaesSketchpad-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`;
    a.href = out.toDataURL('image/png');
    a.click();
  });

  // ==== Undo / Redo
  function persistStrokes(){ localStorage.setItem(STROKE_KEY, JSON.stringify(strokes)); }
  function updateUndoRedoUI() {
    const u = document.getElementById('undoBtn');
    const r = document.getElementById('redoBtn');
    const hasCurrent = currentStroke && currentStroke.points && currentStroke.points.length > 1;
    if (u) u.disabled = (strokes.length === 0 && !hasCurrent);
    if (r) r.disabled = (redoStack.length === 0);
  }
  function undoLast() {
    commitCurrentStroke();
    const last = strokes.pop();
    if (last) { redoStack.push(last); persistStrokes(); redraw(); }
    updateUndoRedoUI();
  }
  function redoLast() {
    const item = redoStack.pop();
    if (item) { strokes.push(item); persistStrokes(); redraw(); }
    updateUndoRedoUI();
  }
  document.getElementById('undoBtn').addEventListener('click', undoLast);
  document.getElementById('redoBtn').addEventListener('click', redoLast);

  // ==== Palette Modal & controls
  const modal = document.getElementById('paletteModal');
  const paletteBtn = document.getElementById('paletteBtn');

  function hexToInputColor(col){
    try {
      const cvs = document.createElement('canvas'); cvs.width = cvs.height = 1;
      const c = cvs.getContext('2d'); c.clearRect(0,0,1,1); c.fillStyle = col; c.fillRect(0,0,1,1);
      const d = c.getImageData(0,0,1,1).data;
      const toHex = v => v.toString(16).padStart(2,'0');
      return '#' + toHex(d[0]) + toHex(d[1]) + toHex(d[2]);
    } catch (err) { return '#000000'; }
  }

  const openPalette = () => {
    document.getElementById('colorPicker').value = hexToInputColor(currentColor);
    modal.classList.add('open'); modal.setAttribute('aria-hidden','false');
  };
  const closePalette = () => { modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); };
  document.getElementById('closePalette').addEventListener('click', closePalette);
  modal.addEventListener('click', (e)=>{ if(e.target === modal) closePalette(); });
  paletteBtn.addEventListener('click', openPalette);

  // Swatches & sizes
  const swatchBar = document.getElementById('swatchBar');
  const SWATCH_SLOTS = 12;
  function renderSwatchBar(){
    swatchBar.innerHTML = '';
    for(let i=0; i<SWATCH_SLOTS; i++){
      const d = document.createElement('button');
      d.className = 'swatch' + (swatches[i] ? '' : ' empty');
      d.style.background = swatches[i] || 'transparent';
      d.title = swatches[i] ? swatches[i] : 'Empty slot';
      if(swatches[i] === currentColor) d.classList.add('active');
      d.addEventListener('click', () => { if(swatches[i]) setColor(swatches[i]); });
      let pressTimer;
      d.addEventListener('pointerdown', () => { pressTimer = setTimeout(()=>{ swatches[i] = currentColor; persistSwatches(); refreshAll(); }, 550); });
      ['pointerup','pointerleave','pointercancel'].forEach(ev=> d.addEventListener(ev, () => clearTimeout(pressTimer)));
      swatchBar.appendChild(d);
    }
    const open = document.createElement('button');
    open.className = 'swatch palette';
    open.title = 'Open colours & brushes';
    open.addEventListener('click', openPalette);
    swatchBar.appendChild(open);
  }
  function setColor(hex){
    currentColor = hex;
    localStorage.setItem('maesketchpad.currentColor', currentColor);
    document.getElementById('colorPicker').value = hexToInputColor(hex);
    document.querySelectorAll('.quick-cell').forEach(cell => {
      cell.classList.toggle('active', cell.style.background === hex);
    });
    refreshAll();
  }

  function renderQuickColors() {
    const quickEl = document.getElementById('quickGrid');
    quickEl.innerHTML = '';
    QUICK_COLORS.forEach(color => {
      const btn = document.createElement('button');
      btn.className = 'quick-cell' + (color === currentColor ? ' active' : '');
      btn.style.background = color;
      btn.title = color;
      btn.addEventListener('click', () => setColor(color));
      quickEl.appendChild(btn);
    });
  }

  const colorPicker = document.getElementById('colorPicker');
  colorPicker.addEventListener('input', e => { setColor(e.target.value); });

  const sizeRange = document.getElementById('size');
  sizeRange.value = String(size);
  sizeRange.addEventListener('input', e => {
    size = parseInt(e.target.value, 10);
    localStorage.setItem('maesketchpad.size', String(size));
  });

  const brushes = document.getElementById('brushes');
  function renderBrushButtons(){
    [...brushes.querySelectorAll('button')].forEach(btn => {
      btn.classList.toggle('active', btn.dataset.brush === brush);
    });
  }
  brushes.addEventListener('click', e => {
    const btn = e.target.closest('button[data-brush]');
    if(!btn) return;
    brush = btn.dataset.brush;
    localStorage.setItem('maesketchpad.brush', brush);
    renderBrushButtons();
  });

  const swatchGridEl = document.getElementById('swatchGrid');
  const GRID_SLOTS = 32;
  function persistSwatches(){ localStorage.setItem(SWATCH_KEY, JSON.stringify(swatches)); }
  function renderSwatchGrid(){
    swatchGridEl.innerHTML = '';
    for(let i=0; i<GRID_SLOTS; i++){
      const cell = document.createElement('button');
      const color = swatches[i];
      cell.className = 'cell' + (color ? '' : ' empty');
      if(color) cell.style.background = color;
      cell.title = color || 'Empty';
      cell.addEventListener('click', () => { if(color) setColor(color); else { swatches[i] = currentColor; persistSwatches(); refreshAll(); } });
      let t; cell.addEventListener('pointerdown', () => { t = setTimeout(()=>{ swatches[i] = currentColor; persistSwatches(); refreshAll(); }, 550); });
      ['pointerup','pointerleave','pointercancel'].forEach(ev=> cell.addEventListener(ev, () => clearTimeout(t)));
      swatchGridEl.appendChild(cell);
    }
  }

  // === Clear drawing & clear colours ===
  document.getElementById('clearSwatches').addEventListener('click', ()=>{
    if (!confirm('Clear all saved colours?')) return;
    swatches = []; persistSwatches(); refreshAll();
  });
  document.getElementById('clearCanvasBtn').addEventListener('click', ()=>{
    if (!confirm('Clear the entire drawing? This cannot be undone.')) return;
    strokes = []; redoStack = [];
    localStorage.removeItem(STROKE_KEY);
    redraw(); updateUndoRedoUI();
  });

  function refreshAll(){
    renderSwatchBar();
    renderSwatchGrid();
    renderBrushButtons();
    renderQuickColors();
  }

  // ==== Navigator (mini-map) with viewport clamping
  let navMap = null;

  const navigatorEl = document.getElementById('navigator');
  const navCanvas = document.getElementById('navCanvas');
  const navCtx = navCanvas.getContext('2d');
  const navToggleBtn = document.getElementById('navToggle');
  const navFitBtn = document.getElementById('navFit');

  const navVisible = localStorage.getItem(NAV_KEY);
  if (navVisible === 'hidden') hideNavigator(); else showNavigator(false);

  function toggleNavigator(){ if (navigatorEl.classList.contains('nav-hidden')) showNavigator(); else hideNavigator(); }
  function showNavigator(save=true){
    navigatorEl.classList.remove('nav-hidden');
    navToggleBtn.textContent = 'üëÅ Hide';
    if (save) localStorage.setItem(NAV_KEY, 'shown');
    drawNavigator();
  }
  function hideNavigator(){
    navigatorEl.classList.add('nav-hidden');
    navToggleBtn.textContent = 'üëÅ Show';
    localStorage.setItem(NAV_KEY, 'hidden');
  }
  navToggleBtn.addEventListener('click', toggleNavigator);
  navFitBtn.addEventListener('click', fitView);

  function unionBoxes(a, b){
    if (!a) return b;
    if (!b) return a;
    return {
      minX: Math.min(a.minX, b.minX),
      minY: Math.min(a.minY, b.minY),
      maxX: Math.max(a.maxX, b.maxX),
      maxY: Math.max(a.maxY, b.maxY),
    };
  }

  function drawNavigator(){
    if (navigatorEl.classList.contains('nav-hidden')) return;

    navCtx.setTransform(1,0,0,1,0,0);
    navCtx.clearRect(0,0,navCanvas.width,navCanvas.height);

    navCtx.fillStyle = '#0b0c10';
    navCtx.fillRect(0,0,navCanvas.width,navCanvas.height);
    navCtx.strokeStyle = '#2a2d36';
    navCtx.strokeRect(0.5,0.5,navCanvas.width-1,navCanvas.height-1);

    const rect = canvas.getBoundingClientRect();
    const topLeftW = screenToWorld(0,0);
    const bottomRightW = screenToWorld(rect.width, rect.height);
    const viewBox = {
      minX: Math.min(topLeftW.x, bottomRightW.x),
      minY: Math.min(topLeftW.y, bottomRightW.y),
      maxX: Math.max(topLeftW.x, bottomRightW.x),
      maxY: Math.max(topLeftW.y, bottomRightW.y),
    };
    const strokesBox = strokesBounds(strokes) || {minX:-100, minY:-70, maxX:100, maxY:70};
    let box = unionBoxes(strokesBox, viewBox);
    const padWorld = 20;
    box = { minX: box.minX - padWorld, minY: box.minY - padWorld, maxX: box.maxX + padWorld, maxY: box.maxY + padWorld };

    const pad = 10;
    const w = Math.max(1, box.maxX - box.minX);
    const h = Math.max(1, box.maxY - box.minY);
    const sx = (navCanvas.width - pad*2) / w;
    const sy = (navCanvas.height - pad*2) / h;
    const s = Math.min(sx, sy);
    const offsetX = Math.round((navCanvas.width - w * s)/2 - box.minX * s);
    const offsetY = Math.round((navCanvas.height - h * s)/2 - box.minY * s);

    navCtx.fillStyle = '#1a1c24';
    navCtx.fillRect(offsetX + box.minX*s, offsetY + box.minY*s, w*s, h*s);

    navCtx.lineCap = 'round'; navCtx.lineJoin = 'round'; navCtx.globalAlpha = 0.9;
    for (const sStroke of strokes){
      const pts = sStroke.points;
      if (!pts || pts.length < 2) continue;
      navCtx.globalCompositeOperation = sStroke.brush==='eraser' ? 'destination-out' : 'source-over';
      navCtx.strokeStyle = sStroke.brush==='eraser' ? '#0b0c10' : (sStroke.color || '#fff');
      navCtx.lineWidth = 1.2;
      navCtx.beginPath();
      navCtx.moveTo(offsetX + pts[0].x*s, offsetY + pts[0].y*s);
      for (let i=1;i<pts.length;i++) navCtx.lineTo(offsetX + pts[i].x*s, offsetY + pts[i].y*s);
      navCtx.stroke();
    }
    navCtx.globalAlpha = 1; navCtx.globalCompositeOperation = 'source-over';

    let vx = offsetX + viewBox.minX * s;
    let vy = offsetY + viewBox.minY * s;
    let vw = (viewBox.maxX - viewBox.minX) * s;
    let vh = (viewBox.maxY - viewBox.minY) * s;

    const clamped = {
      x: Math.max(0, Math.min(vx, navCanvas.width - vw)),
      y: Math.max(0, Math.min(vy, navCanvas.height - vh)),
      w: Math.max(0, Math.min(vw, navCanvas.width)),
      h: Math.max(0, Math.min(vh, navCanvas.height)),
    };

    navCtx.fillStyle = 'rgba(54,200,138,0.15)';
    navCtx.fillRect(clamped.x, clamped.y, clamped.w, clamped.h);
    navCtx.strokeStyle = '#36c88a';
    navCtx.lineWidth = 2;
    navCtx.strokeRect(clamped.x+1, clamped.y+1, Math.max(0,clamped.w-2), Math.max(0,clamped.h-2));

    navMap = { s, offsetX, offsetY, contentBox: box, navRect: clamped };
  }

  // Nav interactions
  let navDragging = false;
  let navDragOffset = {x:0,y:0};
  function navToWorld(nx, ny){
    if (!navMap) return {x:0,y:0};
    const {s, offsetX, offsetY} = navMap;
    return { x: (nx - offsetX) / s, y: (ny - offsetY) / s };
  }
  function centerViewOnWorld(wx, wy){
    const rect = canvas.getBoundingClientRect();
    pan.x = rect.width/2 - wx * zoom;
    pan.y = rect.height/2 - wy * zoom;
    saveView(); redraw();
  }
  navCanvas.addEventListener('pointerdown', (e)=>{
    const bb = navCanvas.getBoundingClientRect();
    const x = (e.clientX - bb.left) * (navCanvas.width / bb.width);
    const y = (e.clientY - bb.top)  * (navCanvas.height / bb.height);
    if (navMap){
      const r = navMap.navRect;
      if (x >= r.x && x <= r.x+r.w && y >= r.y && y <= r.y+r.h){
        navDragging = true;
        if (e.pointerId !== undefined) navCanvas.setPointerCapture?.(e.pointerId);
        navDragOffset.x = x - r.x;
        navDragOffset.y = y - r.y;
      } else {
        const wpt = navToWorld(x, y);
        centerViewOnWorld(wpt.x, wpt.y);
      }
    }
  });
  navCanvas.addEventListener('pointermove', (e)=>{
    if (!navDragging || !navMap) return;
    const bb = navCanvas.getBoundingClientRect();
    const x = (e.clientX - bb.left) * (navCanvas.width / bb.width);
    const y = (e.clientY - bb.top)  * (navCanvas.height / bb.height);
    const halfW = navMap.navRect.w / 2;
    const halfH = navMap.navRect.h / 2;
    const cxClamped = Math.max(halfW, Math.min(x - navDragOffset.x + halfW, navCanvas.width  - halfW));
    const cyClamped = Math.max(halfH, Math.min(y - navDragOffset.y + halfH, navCanvas.height - halfH));
    const wpt = navToWorld(cxClamped, cyClamped);
    centerViewOnWorld(wpt.x, wpt.y);
  });
  window.addEventListener('pointerup', (e)=>{
    if (navDragging){
      navDragging = false;
      try { if (e.pointerId !== undefined) navCanvas.releasePointerCapture?.(e.pointerId); } catch(_){}
    }
  });

  // ==== Boot
  resize();
  window.addEventListener('resize', resize);
  if(swatches.length === 0){
    swatches = ['#000000','#ffffff','#ff595e','#ffca3a','#8ac926','#1982c4','#6a4c93','#f15bb5','#06d6a0','#ffd166','#8338ec','#3a86ff'];
    persistSwatches();
  }
  document.getElementById('zoomLevel').textContent = zoom.toFixed(1) + 'x';
  renderQuickColors();
  refreshAll();
  updateUndoRedoUI();

})();
</script>
</body>
</html>
